from flask import Flask, render_template, url_for, request, jsonify, send_file, redirect, flash
import subprocess
import os
import logging
import requests
import time
import hashlib
import joblib
import json
import io
from forms import ContactForm
from flask_mail import Mail, Message

app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = "/home/ayoub/project/uploads"
app.config['SECRET_KEY'] = '2233'  # Change this to a secure random key

app.config['MAIL_SERVER'] = 'smtp.gmail.com'
app.config['MAIL_PORT'] = 587
app.config['MAIL_USERNAME'] = 'ayoubmendox375@gmail.com'  # Change this to your email
app.config['MAIL_PASSWORD'] = '1234'  # Change this to your email password or app password
app.config['MAIL_USE_TLS'] = True
app.config['MAIL_USE_SSL'] = False

mail = Mail(app)

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

CUCKOO_PATH = "/root/.cuckoo"
API_TOKEN = "cByhrjgSWBcLdjp0sPRr2g"  # Change this to your actual API token
CUCKOO_API_URL = "http://localhost:8090"
AI_MODEL_PATH = "/home/ayoub/project/best_xgb_model.pkl"
HEADERS = {
    "Authorization": f"Bearer {API_TOKEN}"
}

def load_model(model_path):
    model = joblib.load(model_path)
    return model

ai_model = load_model(AI_MODEL_PATH)

def get_md5(file_path):
    hash_md5 = hashlib.md5()
    with open(file_path, 'rb') as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_md5.update(chunk)
    return hash_md5.hexdigest()

def submit_to_cuckoo(file_path, cuckoo_api_url, api_token):
    try:
        headers = {
            'Authorization': f'Bearer {api_token}'
        }
        files = {'file': open(file_path, 'rb')}
        response = requests.post(f"{cuckoo_api_url}/tasks/create/file", headers=headers, files=files)
        response.raise_for_status()
        task_id = response.json().get("task_id")
        logger.info(f"Submitted file {file_path} to Cuckoo with task ID: {task_id}")
        return task_id
    except requests.exceptions.RequestException as e:
        logger.error(f"Error submitting to Cuckoo: {str(e)}")
        return None
    except Exception as e:
        logger.error(f"Unexpected error submitting to Cuckoo: {str(e)}")
        return None

def get_cuckoo_report(task_id, cuckoo_api_url, api_token):
    try:
        headers = {
            'Authorization': f'Bearer {api_token}'
        }
        start_time = time.time()
        timeout = 60

        while True:
            response = requests.get(f"{cuckoo_api_url}/tasks/view/{task_id}", headers=headers)
            if response.status_code == 200:
                task_info = response.json().get("task", {})
                status = task_info.get("status")
                logger.info(f"Current status for task ID {task_id}: {status}")

                if status == "reported":
                    report_url = f"{cuckoo_api_url}/tasks/report/{task_id}"
                    report_response = requests.get(report_url, headers=headers)
                    if report_response.status_code == 200:
                        logger.info(f"Successfully retrieved Cuckoo report for task ID: {task_id}")
                        return report_response.json()
                    else:
                        logger.error(f"Error getting Cuckoo report: {report_response.text}")
                        return None
                else:
                    logger.info(f"Analysis in progress for task ID: {task_id}. Waiting...")

            else:
                logger.error(f"Error getting task info from Cuckoo: {response.text}")
                return None

            if time.time() - start_time > timeout:
                logger.error(f"Timeout reached for task ID: {task_id}. Exiting wait loop.")
                return None

            time.sleep(10)

    except Exception as e:
        logger.error(f"Error getting Cuckoo report: {e}")
        return None

def extract_api_call_sequences(report):
    try:
        api_calls = []
        if 'behavior' in report and 'processes' in report['behavior']:
            for process in report['behavior']['processes']:
                for call in process['calls']:
                    api_calls.append(call['api'])
        else:
            logging.warning("No 'behavior' or 'processes' key found in the report")
            return [], [0] * 100

        filtered_api_calls = []
        previous_call = None
        for call in api_calls:
            if call != previous_call:
                filtered_api_calls.append(call)
                previous_call = call

        if len(filtered_api_calls) < 100:
            repeat_count = (100 // len(filtered_api_calls)) + 1
            filtered_api_calls = (filtered_api_calls * repeat_count)[:100]
        else:
            filtered_api_calls = filtered_api_calls[:100]

        api_call_to_id = {api: idx for idx, api in enumerate(['NtOpenThread', 'ExitWindowsEx', 'FindResourceW', 'CryptExportKey', 'CreateRemoteThreadEx', 'MessageBoxTimeoutW', 'InternetCrackUrlW', 'StartServiceW', 'GetFileSize', 'GetVolumeNameForVolumeMountPointW', 'GetFileInformationByHandle', 'CryptAcquireContextW', 'RtlDecompressBuffer', 'SetWindowsHookExA', 'RegSetValueExW', 'LookupAccountSidW', 'SetUnhandledExceptionFilter', 'InternetConnectA', 'GetComputerNameW', 'RegEnumValueA', 'NtOpenFile', 'NtSaveKeyEx', 'HttpOpenRequestA', 'recv', 'GetFileSizeEx', 'LoadStringW', 'SetInformationJobObject', 'WSAConnect', 'CryptDecrypt', 'GetTimeZoneInformation', 'InternetOpenW', 'CoInitializeEx', 'CryptGenKey', 'GetAsyncKeyState', 'NtQueryInformationFile', 'GetSystemMetrics', 'NtDeleteValueKey', 'NtOpenKeyEx', 'sendto', 'IsDebuggerPresent', 'RegQueryInfoKeyW', 'NetShareEnum', 'InternetOpenUrlW', 'WSASocketA', 'CopyFileExW', 'connect', 'ShellExecuteExW', 'SearchPathW', 'GetUserNameA', 'InternetOpenUrlA', 'LdrUnloadDll', 'EnumServicesStatusW', 'EnumServicesStatusA', 'WSASend', 'CopyFileW', 'NtDeleteFile', 'CreateActCtxW', 'timeGetTime', 'MessageBoxTimeoutA', 'CreateServiceA', 'FindResourceExW', 'WSAAccept', 'InternetConnectW', 'HttpSendRequestA', 'GetVolumePathNameW', 'RegCloseKey', 'InternetGetConnectedStateExW', 'GetAdaptersInfo', 'shutdown', 'NtQueryMultipleValueKey', 'NtQueryKey', 'GetSystemWindowsDirectoryW', 'GlobalMemoryStatusEx', 'GetFileAttributesExW', 'OpenServiceW', 'getsockname', 'LoadStringA', 'UnhookWindowsHookEx', 'NtCreateUserProcess', 'Process32NextW', 'CreateThread', 'LoadResource', 'GetSystemTimeAsFileTime', 'SetStdHandle', 'CoCreateInstanceEx', 'GetSystemDirectoryA', 'NtCreateMutant', 'RegCreateKeyExW', 'IWbemServices_ExecQuery', 'NtDuplicateObject', 'Thread32First', 'OpenSCManagerW', 'CreateServiceW', 'GetFileType', 'MoveFileWithProgressW', 'NtDeviceIoControlFile', 'GetFileInformationByHandleEx', 'CopyFileA', 'NtLoadKey', 'GetNativeSystemInfo', 'NtOpenProcess', 'CryptUnprotectMemory', 'InternetWriteFile', 'ReadProcessMemory', 'gethostbyname', 'WSASendTo', 'NtOpenSection', 'listen', 'WSAStartup', 'socket', 'OleInitialize', 'FindResourceA', 'RegOpenKeyExA', 'RegEnumKeyExA', 'NtQueryDirectoryFile', 'CertOpenSystemStoreW', 'ControlService', 'LdrGetProcedureAddress', 'GlobalMemoryStatus', 'NtSetInformationFile', 'OutputDebugStringA', 'GetAdaptersAddresses', 'CoInitializeSecurity', 'RegQueryValueExA', 'NtQueryFullAttributesFile', 'DeviceIoControl', '__anomaly__', 'DeleteFileW', 'GetShortPathNameW', 'NtGetContextThread', 'GetKeyboardState', 'RemoveDirectoryA', 'InternetSetStatusCallback', 'NtResumeThread', 'SetFileInformationByHandle', 'NtCreateSection', 'NtQueueApcThread', 'accept', 'DecryptMessage', 'GetUserNameExW', 'SizeofResource', 'RegQueryValueExW', 'SetWindowsHookExW', 'HttpOpenRequestW', 'CreateDirectoryW', 'InternetOpenA', 'GetFileVersionInfoExW', 'FindWindowA', 'closesocket', 'RtlAddVectoredExceptionHandler', 'IWbemServices_ExecMethod', 'GetDiskFreeSpaceExW', 'TaskDialog', 'WriteConsoleW', 'CryptEncrypt', 'WSARecvFrom', 'NtOpenMutant', 'CoGetClassObject', 'NtQueryValueKey', 'NtDelayExecution', 'select', 'HttpQueryInfoA', 'GetVolumePathNamesForVolumeNameW', 'RegDeleteValueW', 'InternetCrackUrlA', 'OpenServiceA', 'InternetSetOptionA', 'CreateDirectoryExW', 'bind', 'NtShutdownSystem', 'DeleteUrlCacheEntryA', 'NtMapViewOfSection', 'LdrGetDllHandle', 'NtCreateKey', 'GetKeyState', 'CreateRemoteThread', 'NtEnumerateValueKey', 'SetFileAttributesW', 'NtUnmapViewOfSection', 'RegDeleteValueA', 'CreateJobObjectW', 'send', 'NtDeleteKey', 'SetEndOfFile', 'GetUserNameExA', 'GetComputerNameA', 'URLDownloadToFileW', 'NtFreeVirtualMemory', 'recvfrom', 'NtUnloadDriver', 'NtTerminateThread', 'CryptUnprotectData', 'NtCreateThreadEx', 'DeleteService', 'GetFileAttributesW', 'GetFileVersionInfoSizeExW', 'OpenSCManagerA', 'WriteProcessMemory', 'GetSystemInfo', 'SetFilePointer', 'Module32FirstW', 'ioctlsocket', 'RegEnumKeyW', 'RtlCompressBuffer', 'SendNotifyMessageW', 'GetAddrInfoW', 'CryptProtectData', 'Thread32Next', 'NtAllocateVirtualMemory', 'RegEnumKeyExW', 'RegSetValueExA', 'DrawTextExA', 'CreateToolhelp32Snapshot', 'FindWindowW', 'CoUninitialize', 'NtClose', 'WSARecv', 'CertOpenStore', 'InternetGetConnectedState', 'RtlAddVectoredContinueHandler', 'RegDeleteKeyW', 'SHGetSpecialFolderLocation', 'CreateProcessInternalW', 'NtCreateDirectoryObject', 'EnumWindows', 'DrawTextExW', 'RegEnumValueW', 'SendNotifyMessageA', 'NtProtectVirtualMemory', 'NetUserGetLocalGroups', 'GetUserNameW', 'WSASocketW', 'getaddrinfo', 'AssignProcessToJobObject', 'SetFileTime', 'WriteConsoleA', 'CryptDecodeObjectEx', 'EncryptMessage', 'system', 'NtSetContextThread', 'LdrLoadDll', 'InternetGetConnectedStateExA', 'RtlCreateUserThread', 'GetCursorPos', 'Module32NextW', 'RegCreateKeyExA', 'NtLoadDriver', 'NetUserGetInfo', 'SHGetFolderPathW', 'GetBestInterfaceEx', 'CertControlStore', 'StartServiceA', 'NtWriteFile', 'Process32FirstW', 'NtReadVirtualMemory', 'GetDiskFreeSpaceW', 'GetFileVersionInfoW', 'FindFirstFileExW', 'FindWindowExW', 'GetSystemWindowsDirectoryA', 'RegOpenKeyExW', 'CoCreateInstance', 'NtQuerySystemInformation', 'LookupPrivilegeValueW', 'NtReadFile', 'ReadCabinetState', 'GetForegroundWindow', 'InternetCloseHandle', 'FindWindowExA', 'ObtainUserAgentString', 'CryptCreateHash', 'GetTempPathW', 'CryptProtectMemory', 'NetGetJoinInformation', 'NtOpenKey', 'GetSystemDirectoryW', 'DnsQuery_A', 'RegQueryInfoKeyA', 'NtEnumerateKey', 'RegisterHotKey', 'RemoveDirectoryW', 'FindFirstFileExA', 'CertOpenSystemStoreA', 'NtTerminateProcess', 'NtSetValueKey', 'CryptAcquireContextA', 'SetErrorMode', 'UuidCreate', 'RtlRemoveVectoredExceptionHandler', 'RegDeleteKeyA', 'setsockopt', 'FindResourceExA', 'NtSuspendThread', 'GetFileVersionInfoSizeExW', 'NtOpenDirectoryObject', 'InternetQueryOptionA', 'InternetReadFileExA', 'InternetQueryOptionW', 'NtQueryObject', 'WinVerifyTrust', 'LdrLoadDll', 'InternetReadFile', 'InternetConnectA', 'InternetConnectW', 'SetFilePointerEx', 'ExitProcess', 'GetCommandLineA', 'InternetOpenA', 'InternetOpenW', 'InternetCrackUrlA', 'InternetCrackUrlW', 'CreateFileA', 'CreateFileW', 'NtCreateFile', 'LoadLibraryA', 'LoadLibraryW', 'GetProcAddress', 'NtOpenDirectoryObject', 'GetCommandLineW',])}

        api_call_ids = [api_call_to_id.get(call, api_call_to_id.get('__anomaly__', 0)) for call in filtered_api_calls]
        return filtered_api_calls, api_call_ids
        
    except Exception as e:
        logging.error(f"Error in extract_api_call_sequences: {str(e)}")
        return [], [0] * 100

@app.route('/')
def index():
    return render_template('home.html')

@app.route('/home')
def home():
    return render_template('home.html')

def get_recent_analyses():
    try:
        response = requests.get(f"{CUCKOO_API_URL}/tasks/recent/", headers=HEADERS)
        if response.status_code == 200:
            tasks = response.json()['tasks']
            recent_analyses = []
            for task in tasks[:5]:  # Limit to 5 most recent tasks
                analysis = {
                    'file_name': task.get('target', 'Unknown'),
                    'submission_time': time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(task.get('added_on', 0))),
                    'status': task.get('status', 'Unknown'),
                    'threat_level': get_threat_level(task['id']) if task.get('status') == 'reported' else 'N/A',
                    'report_url': url_for('get_report', task_id=task['id'])
                }
                recent_analyses.append(analysis)
            return recent_analyses
        else:
            logging.error(f"Failed to retrieve recent tasks: {response.text}")
            return []
    except Exception as e:
        logging.error(f"Error in get_recent_analyses: {str(e)}")
        return []

def get_threat_level(task_id):
    try:
        prediction = get_prediction(task_id)
        return 'Malware' if prediction == 'Malware' else 'Goodware'
    except Exception as e:
        logging.error(f"Error getting threat level for task {task_id}: {str(e)}")
        return 'Unknown'

@app.route('/contact', methods=['GET', 'POST'])
def contact():
    form = ContactForm()
    if form.validate_on_submit():
        name = form.name.data
        email = form.email.data
        message = form.message.data
        
        try:
            msg = Message("New Contact Form Submission",
                          sender=email,
                          recipients=["your-email@example.com"])  # Change this to your email
            msg.body = f"From: {name}\nEmail: {email}\n\nMessage:\n{message}"
            mail.send(msg)
            flash('Your message has been sent successfully!', 'success')
        except Exception as e:
            logger.error(f"Failed to send email: {str(e)}")
            flash('Sorry, there was an error sending your message. Please try again later.', 'error')
        
        return redirect(url_for('contact'))
    
    return render_template('contact.html', form=form)

@app.route('/search_md5', methods=['POST'])
def search_md5():
    md5_hash = request.form.get('md5_hash')
    logger.info(f"Searching for MD5: {md5_hash}")

    file_info = get_file_info_by_md5(md5_hash)
    
    if file_info:
        tasks_info = get_task_info_from_cuckoo(md5_hash)
        if tasks_info:
            file_info.update(tasks_info)
        logger.info(f"File info to be rendered: {file_info}")
        return render_template('search_md5.html', file_info=file_info)
    else:
        return render_template('search_md5.html', error="No file found with the given MD5 hash")

def get_file_info_by_md5(md5_hash):
    upload_folder = app.config['UPLOAD_FOLDER']

    for root, dirs, files in os.walk(upload_folder):
        for filename in files:
            file_path = os.path.join(root, filename)
            if get_md5(file_path) == md5_hash:
                file_stats = os.stat(file_path)

                return {
                    'name': filename,
                    'md5_hash': md5_hash,
                    'submission_date': time.ctime(file_stats.st_ctime),
                    'task_id': None,
                    'status': None,
                    'prediction': None
                }

    logger.warning(f"No file found with the given MD5 hash: {md5_hash}")
    return None

def get_task_info_from_cuckoo(md5_hash):
    try:
        url = f"{CUCKOO_API_URL}/files/view/md5/{md5_hash}"
        response = requests.get(url, headers=HEADERS)
        response.raise_for_status()
        file_info = response.json().get('sample', {})

        logger.info(f"File info from Cuckoo: {file_info}")

        if file_info:
            file_id = file_info.get('id')

            task_info = {'task_id': None, 'status': 'Not analyzed', 'prediction': 'Not analyzed'}
            
            if file_info.get('tasks'):
                for task_id in file_info['tasks']:
                    task_url = f"{CUCKOO_API_URL}/tasks/view/{task_id}"
                    task_response = requests.get(task_url, headers=HEADERS)
                    task_response.raise_for_status()
                    task_data = task_response.json().get('task', {})
                    logger.info(f"Task data for task_id {task_id}: {task_data}")
                    status = task_data.get('status', 'Not analyzed')

                    task_info['task_id'] = task_id
                    task_info['status'] = status

                    if status == 'reported':
                        task_info['prediction'] = get_prediction(task_id)

                return task_info
            else:
                logger.warning(f"No tasks found for file with MD5 hash: {md5_hash}")
                return task_info

        else:
            logger.warning(f"No file found with the given MD5 hash: {md5_hash}")
            return None

    except requests.RequestException as e:
        logger.error(f"Error getting task info from Cuckoo: {str(e)}")
        return None
    except Exception as e:
        logger.error(f"Unexpected error in get_task_info_from_cuckoo: {str(e)}")
        return None

@app.route('/analyze', methods=['POST'])
def analyze_file():
    try:
        report = request.json
        filtered_api_calls, api_call_ids = extract_api_call_sequences(report)
        return jsonify({'status': 'success', 'api_calls': filtered_api_calls}), 200
    except Exception as e:
        logging.error(f"Error in analyze_file endpoint: {str(e)}")
        return jsonify({'status': 'error', 'message': 'Internal server error'}), 500

@app.route('/submit_file', methods=['POST'])
def submit_file():
    if 'file' not in request.files:
        return jsonify({"status": "error", "message": "No file part"})
    
    file = request.files['file']
    if file.filename == '':
        return jsonify({"status": "error", "message": "No selected file"})
    
    if file:
        try:
            os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
            filename = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
            file.save(filename)
            logger.info(f"File saved successfully: {filename}")

            md5_hash = get_md5(filename)
            logger.info(f"MD5 hash for {filename}: {md5_hash}")

        except Exception as e:
            logger.error(f"Error saving file: {str(e)}")
            return jsonify({"status": "error", "message": f"Error saving file: {str(e)}"})
        
        task_id = submit_to_cuckoo(filename, CUCKOO_API_URL, API_TOKEN)
        if task_id is not None:
            return jsonify({
                "status": "success", 
                "task_id": task_id,
                "md5_hash": md5_hash
            })
        else:
            return jsonify({"status": "error", "message": "Error submitting file to Cuckoo"})

@app.route('/get_tasks', methods=['GET'])
def get_tasks():
    try:
        response = requests.get(f"{CUCKOO_API_URL}/tasks/list", headers=HEADERS)
        if response.status_code == 200:
            tasks = response.json()['tasks']
            for task in tasks:
                if task['status'] == 'reported':
                    prediction = get_prediction(task['id'])
                    task['prediction'] = prediction
                else:
                    task['prediction'] = '-'
            return jsonify(tasks), 200
        else:
            return jsonify({"error": "Failed to retrieve tasks"}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500

def get_prediction(task_id):
    try:
        report = get_cuckoo_report(task_id, CUCKOO_API_URL, API_TOKEN)
        if report:
            _, api_call_ids = extract_api_call_sequences(report)
            prediction = ai_model.predict([api_call_ids])[0]
            return 'Malware' if prediction == 1 else 'Goodware'
        else:
            logger.warning(f"No report received for task {task_id}")
            return 'Error'
    except Exception as e:
        logger.error(f"Error getting prediction for task {task_id}: {str(e)}")
        return 'Error'

@app.route('/submissions')
def submissions():
    return render_template('submissions.html')

@app.route('/faq')
def faq():
    return render_template('FAQ.html')

@app.route('/start_cuckoo', methods=['POST'])
def start_cuckoo():
    try:
        subprocess.run(['supervisorctl', '-c', f'{CUCKOO_PATH}/supervisord.conf', 'start', 'all'], check=True)
        return jsonify({'status': 'success', 'message': 'All services started successfully.'})
    except subprocess.CalledProcessError as e:
        return jsonify({'status': 'error', 'message': f'Error starting services: {e}'}), 500

@app.route('/check_status/<int:task_id>', methods=['GET'])
def check_status(task_id):
    response = requests.get(f"{CUCKOO_API_URL}/tasks/view/{task_id}", headers=HEADERS)
    if response.status_code == 200:
        task_info = response.json()
        return jsonify(task_info), 200
    else:
        return jsonify({"error": "Failed to retrieve task status"}), 500

@app.route('/get_report/<int:task_id>', methods=['GET'])
def get_report(task_id):
    report = get_cuckoo_report(task_id, CUCKOO_API_URL, API_TOKEN)
    if report:
        report_json = json.dumps(report, indent=2)
        buffer = io.BytesIO(report_json.encode('utf-8'))
        buffer.seek(0)
        return send_file(
            buffer,
            as_attachment=True,
            download_name=f'report_{task_id}.json',
            mimetype='application/json'
        )
    else:
        return jsonify({"error": "Failed to retrieve report"}), 500

if __name__ == '__main__':
    if not os.path.exists(app.config['UPLOAD_FOLDER']):
        os.makedirs(app.config['UPLOAD_FOLDER'])
    app.run(debug=True, host='0.0.0.0', port=5000)